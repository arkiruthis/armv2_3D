#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "Math3D.h"
#include "Mesh.h"
#include "CVector.h"

// ASM Routines
extern void VDUSetup(void);
extern void SetBuffers(int oneOver); // (R1: oneOver)
extern void UpdateMemAddress(int screenStart);
extern void ReserveScreenBanks(void);
extern void SwitchScreenBank(void);
extern void SortVertices(int triList);
extern void DrawTriangle(int triList, int color);
extern void ClearScreen(int color, int fullclear);
extern int KeyPress(int keyCode);

// GLOBALS
static unsigned char color; // <uint8> color
static unsigned int color4; // <uint32> color (4 x the above)
_kernel_oserror *err;
_kernel_swi_regs rin, rout;

// A selection of 4 x 16-level gradients from the default Archimedes 256 color palette
unsigned char palette[64] = { 0, 1, 2, 3, 44, 45, 46, 47, 208, 209, 210, 211, 252, 253, 254, 255, // GREY
                              32, 33, 34, 35, 64, 65, 66, 67, 96, 97, 98, 99, 103, 111, 243, 255, // GREEN
                              4, 4, 4, 4, 4, 5, 6, 7, 56, 57, 58, 59, 212, 213, 215, 215,         // RED
                              8, 9, 10, 11, 160, 161, 162, 163, 200, 201, 202, 203, 232, 234, 235, 236 }; // BLUE

unsigned pal16[16 * 3];

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
#define MAXDEPTH 512

int cmpfunc (const void * a, const void * b) {
   return ( ((TRI*)b)->depth - ((TRI*)a)->depth );
}

void SetPalette()
{
    typedef struct PalEntry {
        unsigned char VDU, INDEX, MODE, R, G, B;
    } PalEntry;

    PalEntry pal;
    int i = 0;

    pal.VDU = 19;
    pal.MODE = 16;

    rin.r[0] = (unsigned int)&pal;
    rin.r[1] = 6;

    for (i = 0; i < 16; ++i)
    {
        pal.R = i << 4;
        pal.G = i << 4;
        pal.B = i << 4;
        pal.INDEX = i;

        err = _kernel_swi(OS_WriteN, &rin, &rout);
    }
}

int main(int argc, char *argv[])
{
    int swi_data[10], isRunning = 1, isSpinning = 1;
    unsigned char heading = 64, pitch = 0, bank = 0;
    unsigned int i;
    char buf[256], colorIndex = 0;
    unsigned int *ptr;
    char *tmp;
    fix scale;
    V3D _verts[4], tmpVec;
    V2D v[3];
    MAT43 mat;
    TRI *RenderQueue[MAXDEPTH], *queuePtr = NULL;

    memset(&RenderQueue[0], NULL, sizeof(TRI*) * MAXDEPTH);

    for (i = 0; i < 256; ++i)
    {
        g_SineTable[i] = float2fix(sin((i * M_PI * 2.0) / 255.0));
        g_OneOver[i] = (i < 1) ? float2fix(1.f) : float2fix(1.f / i);
    }

    for (i = 0; i < 16; ++i) 
    {
        pal16[i * 3] = i << 4;
        pal16[1 + i * 3] = i << 4;
        pal16[2 + i * 3] = i << 4;
    }

    tmp = getenv("Game$Dir");

    sprintf(&buf[0], "%s.Ship_obj", tmp);
    tmp = &buf[0];
    if (LoadOBJ(tmp) != 0)
    {
        printf("Unable to load file. Please use the !Run script.\n");
        return 1;
    }

	printf("CONTROLS:\nF1-F4: Set Color\nSPACE: Start/Stop Spin\n");
	printf("NUMPAD: 4/6 Heading, 8/2 Pitch, 7/9 Bank\n");
	printf("ESC: Exit Program\n--\n");
    printf("Press any key to continue...");

    // Uncomment to pause here and read data output
    // buf[0] = getchar();

    VDUSetup();
    ReserveScreenBanks();
    SwitchScreenBank();
    SetBuffers((unsigned int)(&g_OneOver[0])); // Store these on the ASM side for use there
    SetPalette();

    // Obtain details about the current screen mode
    swi_data[0] = (int)148;         // screen base address
    swi_data[1] = (int)7;           // screen size
    swi_data[1] = (int)-1;          // terminate query
    rin.r[0] = (int)(&swi_data[0]); // Start of query
    rin.r[1] = (int)(&swi_data[3]); // Results
    err = _kernel_swi(OS_ReadVduVariables, &rin, &rout);
    UpdateMemAddress(swi_data[3]);

    for (i = 0; i < 2; ++i)
    {
        SwitchScreenBank(); // Swap draw buffer with display buffer
        rin.r[0] = (int)(&swi_data[0]); // Get the new screen start address
        rin.r[1] = (int)(&swi_data[3]); // Results
        err = _kernel_swi(OS_ReadVduVariables, &rin, &rout);
        UpdateMemAddress(swi_data[3]); // Pass these to the ASM side
        ClearScreen(0x0, 1); // Clear the new draw buffer
    }

    if (err == NULL)
    {
        for (i = 0; i < cvector_size(g_Mesh.verts); ++i)
        {
            g_Mesh.verts[i].x = multfix(g_Mesh.verts[i].x, int2fix(65));
            g_Mesh.verts[i].y = multfix(g_Mesh.verts[i].y, int2fix(65));
            g_Mesh.verts[i].z = multfix(g_Mesh.verts[i].z, int2fix(65));
        }

        while (isRunning)
        {
            // TODO, disable "escape condition" OS_Byte 124 and handle Escape key directly.
            // isRunning = !KeyPress(112);

            if (KeyPress(98)) // Spacebar
                isSpinning = !isSpinning;
            if (KeyPress(113)) // F1
                colorIndex = 0;
            if (KeyPress(114)) // F2
                colorIndex = 16;
            if (KeyPress(115)) // F3
                colorIndex = 32;
            if (KeyPress(20)) // F4
                colorIndex = 48;

            if (isSpinning)
            {
                heading += 2;
                bank --;
            }

            if (KeyPress(122)) // Numeric Keypad 4
                heading -= 2;
            if (KeyPress(26)) // Numeric Keypad 6
                heading += 2;
            if (KeyPress(42)) // Numeric Keypad 8
                pitch -= 2;
            if (KeyPress(124)) // Numeric Keypad 2
                pitch += 2;
            if (KeyPress(27)) // Numeric Keypad 7
                bank -= 2;
            if (KeyPress(43)) // Numeric Keypad 9
                bank += 2;

            SwitchScreenBank(); // Swap draw buffer with display buffer
            rin.r[0] = (int)(&swi_data[0]); // Get the new screen start address
            rin.r[1] = (int)(&swi_data[3]); // Results
            err = _kernel_swi(OS_ReadVduVariables, &rin, &rout);
            UpdateMemAddress(swi_data[3]); // Pass these to the ASM side

            rin.r[0] = 12;
            err = _kernel_swi(OS_WriteC, &rin, &rout);

            //ClearScreen(0x0, 1); // Clear the new draw buffer

            EulerToMat(&mat, heading, pitch, bank);

            // Rotate vertices and move into the negative Z space
            // and perform a rudimentary perspective transform.
            for (i = 0; i < cvector_size(g_Mesh.verts); ++i)
            {
                MultV3DMat(&g_Mesh.verts[i], &g_Mesh.verts_transformed[i], &mat);
                g_Mesh.verts_transformed[i].z -= int2fix(200);

                scale = int2fix(230) / (g_Mesh.verts_transformed[i].z >> 16);

                g_Mesh.verts_transformed[i].x = multfix(g_Mesh.verts_transformed[i].x, (scale));
                g_Mesh.verts_transformed[i].y = multfix(g_Mesh.verts_transformed[i].y, (scale));
            }

            // Look at the transformed normal for each face and decide whether
            // to include it in the next render queue.
            for (i = 0; i < cvector_size(g_Mesh.faces); ++i)
            {
                g_Mesh.faces[i].next = NULL;
                _verts[0] = g_Mesh.verts_transformed[g_Mesh.faces[i].a];
                _verts[1] = g_Mesh.verts_transformed[g_Mesh.faces[i].b];
                _verts[2] = g_Mesh.verts_transformed[g_Mesh.faces[i].c];
                if (orient2d(_verts[0], _verts[1], _verts[2]) > 0)
                {
                    MultV3DMat(&g_Mesh.faces[i].normal, &tmpVec, &mat);
                    // Add face to the destination list if it is facing us
                    g_Mesh.faces[i].d = MIN(MAX(tmpVec.z / 4500, 0), 15);
                    g_Mesh.faces[i].d |= (g_Mesh.faces[i].d << 4);
                    // Important to invert the depth here as the camera looks into -Z
                    // but our RenderQueue is indexed by positive numbers
                    g_Mesh.faces[i].depth = -((_verts[0].z + _verts[1].z + _verts[2].z) >> 17);
                    // Push the previous triangle (if any) onto the stack for this depth.
                    g_Mesh.faces[i].next = RenderQueue[g_Mesh.faces[i].depth];
                    RenderQueue[g_Mesh.faces[i].depth] = &g_Mesh.faces[i];
                }
            }

            // Painter's algorithm. Proceed from furthest to nearest.
            for (i=MAXDEPTH - 1;i !=0; i--) {
                while (RenderQueue[i]) {  // Render faces with current depth
                    queuePtr = RenderQueue[i];
                    _verts[0] = g_Mesh.verts_transformed[queuePtr->a];
                    _verts[1] = g_Mesh.verts_transformed[queuePtr->b];
                    _verts[2] = g_Mesh.verts_transformed[queuePtr->c];

                    // Offset to the screen center (160,128)
                    // Also clear fixed point mantissa to prevent glitchy delta values
                    v[0].x = 160 + fix2int(_verts[0].x);
                    v[0].y = 128 + fix2int(_verts[0].y);
                    v[1].x = 160 + fix2int(_verts[1].x);
                    v[1].y = 128 + fix2int(_verts[1].y);
                    v[2].x = 160 + fix2int(_verts[2].x);
                    v[2].y = 128 + fix2int(_verts[2].y);

                    color =  queuePtr->d; // The palette index for this face
                    color4 = (color << 24) | (color << 16) | (color << 8) | color;

                    SortVertices((unsigned int)(&v[0].x));
                    DrawTriangle((unsigned int)(&v[0].x), color4);
                    RenderQueue[i] = (TRI*)queuePtr->next; // Next face
                }
            }

            // Uncomment the following to print debug output top-left
            /*
            rin.r[0] = 256 + 30;
            err = _kernel_swi(OS_WriteC, &rin, &rout);
            printf("\n -- stuff to output -- \n");
            */
        }
    }
    else
    {
        printf("ERROR: %s", err->errmess);
    }

    FreeMesh();

    return 0;
}
